Require Import OrderedTypeEx Generate.

From Coq Require Import Ascii String.

Generate OrderedType ascii.
Generate OrderedType string.

Open Scope string.

Eval vm_compute in "cat" =?= "dog".

Require Import Sets.

Eval vm_compute in
    cardinal {"dog"; {"cat"; {"dog"; {"hamster"; {}}}}}.

Inductive tree :=
| Tree (n : nat) (ts : trees)
with trees :=
| TNil
| TCons (t : tree) (ts : trees).

Generate OrderedType tree.

(** Following is a manual instantiation of OrderedType
    for [tree] and [trees]. It is useful to manually debug
    the generic tactics used by Generate OrderedType when
    something goes wrong. 
 *)
(* Inductive tree_eq : tree -> tree -> Prop := *)
(* | tree_eq_Tree : *)
(*     forall n n' ts ts', *)
(*       n === n' -> trees_eq ts ts' -> *)
(*       tree_eq (Tree n ts) (Tree n' ts') *)
(* with trees_eq : trees -> trees -> Prop := *)
(* | trees_eq_TNil : *)
(*     trees_eq TNil TNil *)
(* | trees_eq_TCons : *)
(*     forall t t' ts ts', *)
(*       tree_eq t t' -> *)
(*       trees_eq ts ts' -> *)
(*       trees_eq (TCons t ts) (TCons t' ts'). *)

(* Lemma tree_eq_refl : forall t, tree_eq t t *)
(* with trees_eq_refl : forall ts, trees_eq ts ts. *)
(* Proof. *)
(*   - destruct t; constructor; try reflexivity; auto. *)
(*   - destruct ts; constructor; try reflexivity; auto. *)
(* Qed. *)
(* Lemma tree_eq_sym : forall t t', tree_eq t t' -> tree_eq t' t *)
(* with trees_eq_sym : forall ts ts', trees_eq ts ts' -> trees_eq ts' ts. *)
(* Proof. *)
(*   - intros ? ? H; inversion_clear H; constructor; try symmetry; auto. *)
(*   - intros ? ? H; inversion_clear H; constructor; try symmetry; auto. *)
(* Qed. *)
(* Lemma tree_eq_trans : forall t t' t'', tree_eq t t' -> tree_eq t' t'' -> tree_eq t t'' *)
(* with trees_eq_trans : forall ts ts' ts'', trees_eq ts ts' -> trees_eq ts' ts'' -> trees_eq ts ts''. *)
(* Proof. *)
(*   - intros ? ? ? H H'. *)
(*     inversion H; subst; clear H. inversion H'; subst; clear H'. *)
(*     constructor; eauto. transitivity n'; assumption. *)
(*   - intros ? ? ? H H'; *)
(*       inversion H; subst; clear H; inversion H'; subst; clear H'. *)
(*     constructor. *)
(*     constructor; eauto. *)
(* Qed. *)

(* Instance tree_eq_Equivalence : Equivalence tree_eq := *)
(*   Build_Equivalence _ tree_eq_refl tree_eq_sym tree_eq_trans. *)
(* Instance trees_eq_Equivalence : Equivalence trees_eq := *)
(*   Build_Equivalence _ trees_eq_refl trees_eq_sym trees_eq_trans. *)

(* Inductive tree_lt : tree -> tree -> Prop := *)
(* | tree_lt_Tree_1 : *)
(*     forall n n' ts ts', *)
(*       n <<< n' -> *)
(*       tree_lt (Tree n ts) (Tree n' ts') *)
(* | tree_lt_Tree_2 : *)
(*     forall n n' ts ts', *)
(*       n === n' -> trees_lt ts ts' -> *)
(*       tree_lt (Tree n ts) (Tree n' ts') *)
(* with trees_lt : trees -> trees -> Prop := *)
(* | trees_lt_TNil_TCons : *)
(*     forall t ts, *)
(*       trees_lt TNil (TCons t ts) *)
(* | trees_lt_TCons_1 : *)
(*     forall t t' ts ts', *)
(*       tree_lt t t' -> *)
(*       trees_lt (TCons t ts) (TCons t' ts') *)
(* | trees_lt_TCons_2 : *)
(*     forall t t' ts ts', *)
(*       t === t' -> *)
(*       trees_lt ts ts' -> *)
(*       trees_lt (TCons t ts) (TCons t' ts'). *)

(* Lemma tree_lt_irrefl : forall t t', tree_lt t t' -> t === t' -> False *)
(* with trees_lt_irrefl : forall ts ts', trees_lt ts ts' -> ts === ts' -> False. *)
(* Proof. *)
(*   - intros ? ? Hlt Heq; inversion Heq; subst; clear Heq; *)
(*       inversion Hlt; subst; clear Hlt; eauto; order. *)
(*   - intros ? ? Hlt Heq; inversion Heq; subst; clear Heq; *)
(*       inversion Hlt; subst; clear Hlt; eauto. *)
(* Qed. *)

(* Lemma tree_eq_lt : forall t t' t'', t === t' -> tree_lt t t'' -> tree_lt t' t'' *)
(* with trees_eq_lt : forall ts ts' ts'', ts === ts' -> trees_lt ts ts'' -> trees_lt ts' ts''. *)
(* Proof. *)
(*   - intros ? ? ? Heq Hlt; inversion Heq; subst; clear Heq; *)
(*       inversion Hlt; subst; clear Hlt. *)
(*     constructor; order. *)
(*     constructor 2; eauto; order. *)
(*   - intros ? ? ? Heq Hlt; inversion Heq; subst; clear Heq; *)
(*       inversion Hlt; subst; clear Hlt. *)
(*     constructor. *)
(*     constructor; eauto; order. *)
(*     constructor 3; eauto; order. *)
(* Qed. *)
(* Lemma tree_eq_gt : forall t t' t'', t === t' -> tree_lt t'' t -> tree_lt t'' t' *)
(* with trees_eq_gt : forall ts ts' ts'', ts === ts' -> trees_lt ts'' ts -> trees_lt ts'' ts'. *)
(* Proof. *)
(*   - intros ? ? ? Heq Hlt; inversion Heq; subst; clear Heq; *)
(*       inversion Hlt; subst; clear Hlt. *)
(*     constructor. now rewrite <- H. *)
(*     constructor 2; eauto; order. *)
(*   - intros ? ? ? Heq Hlt; inversion Heq; subst; clear Heq; *)
(*       inversion Hlt; subst; clear Hlt. *)
(*     constructor. *)
(*     constructor; eauto; order. *)
(*     constructor 3; eauto; order. *)
(* Qed. *)

(* Lemma tree_lt_trans : forall t t' t'', tree_lt t t' -> tree_lt t' t'' -> tree_lt t t'' *)
(* with trees_lt_trans : forall ts ts' ts'', trees_lt ts ts' -> trees_lt ts' ts'' -> trees_lt ts ts''. *)
(* Proof. *)
(*   - intros ? ? ? H1 H2; inversion H1; subst; clear H1; *)
(*       inversion H2; subst; clear H2. *)
(*     constructor; etransitivity; eauto. *)
(*     constructor; now rewrite <- H3. *)
(*     constructor; now rewrite H. *)
(*     constructor 2. now transitivity n'. eauto. *)
(*   - intros ? ? ? H1 H2; inversion H1; subst; clear H1; *)
(*       inversion H2; subst; clear H2; eauto. *)
(*     constructor. constructor. *)
(*     constructor; eauto. *)
(*     constructor; eauto using tree_eq_gt. *)
(*     constructor; symmetry in H; eauto using tree_eq_lt. *)
(*     constructor 3; eauto. order. *)
(* Qed. *)

(* Instance tree_lt_StrictOrder : StrictOrder tree_lt tree_eq := *)
(*   Build_StrictOrder _ _ _ _ tree_lt_trans tree_lt_irrefl. *)
(* Instance trees_lt_StrictOrder : StrictOrder trees_lt trees_eq := *)
(*   Build_StrictOrder _ _ _ _ trees_lt_trans trees_lt_irrefl. *)

(* Fixpoint tree_cmp (t t' : tree) : comparison := *)
(*   match t with *)
(*   | Tree n ts => *)
(*     match t' with *)
(*     | Tree n' ts' => *)
(*       match n =?= n' with *)
(*       | Eq => trees_cmp ts ts' *)
(*       | c => c *)
(*       end *)
(*     end *)
(*   end *)
(* with trees_cmp (ts ts' : trees) : comparison := *)
(*   match ts with *)
(*   | TNil => *)
(*     match ts' with *)
(*     | TNil => Eq *)
(*     | TCons _ _ => Lt *)
(*     end *)
(*   | TCons t ts => *)
(*     match ts' with *)
(*     | TNil => Gt *)
(*     | TCons t' ts' => *)
(*       match tree_cmp t t' with *)
(*       | Eq => trees_cmp ts ts' *)
(*       | c => c *)
(*       end *)
(*     end *)
(*   end. *)

(* Lemma tree_compare_spec : forall t t', compare_spec tree_eq tree_lt t t' (tree_cmp t t') *)
(* with trees_compare_spec : forall ts ts', compare_spec trees_eq trees_lt ts ts' (trees_cmp ts ts'). *)
(* Proof. *)
(*   - destruct t; destruct t'; simpl. *)
(*     destruct (compare_dec n n0). *)
(*     constructor; constructor; auto. *)
(*     destruct (trees_compare_spec ts ts0); constructor. *)
(*     constructor 2; auto. *)
(*     constructor; auto. *)
(*     constructor 2; auto. *)
(*     constructor; constructor; auto. *)
(*   - destruct ts; destruct ts'; simpl. *)
(*     constructor; constructor. *)
(*     constructor; constructor. *)
(*     constructor; constructor. *)
(*     destruct (tree_compare_spec t t0). *)
(*     constructor; constructor; auto. *)
(*     destruct (trees_compare_spec ts ts'); constructor. *)
(*     constructor 3; auto. *)
(*     constructor; auto. *)
(*     constructor 3; auto. *)
(*     constructor; constructor; auto. *)
(* Qed. *)

(* Instance tree_OrderedType : OrderedType tree := *)
(*   Build_OrderedType _ tree_eq tree_lt _ _ tree_cmp tree_compare_spec. *)
(* Instance trees_OrderedType : OrderedType trees := *)
(*   Build_OrderedType _ trees_eq trees_lt _ _ trees_cmp trees_compare_spec. *)